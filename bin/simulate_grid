#!/usr/bin/env python

### importing packages
import argparse
import os
import numpy as np
import pandas as pd
import pickle
import datetime
import tsinfer
import tsdate
import math
import msprime
import tskit
from egrm import varGRM_C, mTMRCA_C, mTMRCA, gmTMRCA, hmTMRCA

### ad-hoc functions ###
def getX(trees, idx):
  N = trees.num_samples
  M = idx.shape[0]
  X = np.zeros((N, M)).astype("int")
  i = 0; num = 0
  for v in trees.variants():
    if i in idx:
      X[:, num] = v.genotypes; num += 1
    i += 1
  return X

def getK(trees, idx):
  N = trees.num_samples
  M = idx.shape[0]
  K_all = np.zeros((N, N))
  for idx_ in np.split(idx, range(1000, M, 1000)):
    Z = getX(trees, idx_).astype("float")
    Z -= Z.mean(axis=0); Z /= Z.std(axis=0)
    K_all += np.dot(Z, np.transpose(Z))
    del Z
  K_all /= M
  return K_all

def step_mig_mat(m,n):
  n2 = n ** 2
  pmat=np.arange(0, n2).reshape(n,n)
  mmat=np.zeros(shape=[n2,n2])
  
  def contain(ix,max_ix):
    if ix<0:
      return(0)
    if ix>(max_ix-1):
      return(max_ix-1)
    else:
      return(ix)
  
  for ii in range(n2):
    center_ix=np.where(pmat==ii)
    top_ix=pmat[contain(center_ix[0]-1,n),contain(center_ix[1],n)]
    bottom_ix=pmat[contain(center_ix[0]+1,n),contain(center_ix[1],n)]
    left_ix=pmat[contain(center_ix[0],n),contain(center_ix[1]-1,n)]
    right_ix=pmat[contain(center_ix[0],n),contain(center_ix[1]+1,n)]
    
    mmat[ii,top_ix]=mmat[ii,bottom_ix]=mmat[ii,left_ix]=mmat[ii,right_ix]=m
    mmat[top_ix,ii]=mmat[bottom_ix,ii]=mmat[left_ix,ii]=mmat[right_ix,ii]=m
    mmat[ii,ii]=0
  
  return(mmat)

### parse arguments ###
parser=argparse.ArgumentParser()

# name of simulation
parser.add_argument('--name', type = str, help='output file name')

# workflow control
parser.add_argument('--all', help='run all steps', action='store_true')
parser.add_argument('--relate', help='run relate tree reconstruction', action='store_true')
parser.add_argument('--tsinfer', help='run tsinfer tree reconstruction', action='store_true')
parser.add_argument('--mtmrca', help='compute mean TMRCA', action='store_true')

# simulation arguments
parser.add_argument('--N_per_pop', type = int, help='population size')
parser.add_argument('--n', type = int, help='grid size')
parser.add_argument('--migration_rate', type = float, help='migration rate')
parser.add_argument('--time_move', type = float, help='move time')

parser.add_argument('--l', type = int, help='chromosome length')
parser.add_argument('--mutation_rate', type = float, help='mutation rate')
parser.add_argument('--recomb_rate', type = float, help='recombination rate')
parser.add_argument('--cas_ratio', type = float, help='M_cas / M')
parser.add_argument('--obs_ratio', type = float, help='M_obs / M_5')
parser.add_argument('--h2g', type = float, help='heritability')
parser.add_argument('--Alpha', type = float, help='Alpha -- causal probability parameter')
parser.add_argument('--Beta', type = float, help='Beta -- observation probability parameter')

args = vars(parser.parse_args())
args = dict((k,v) for k,v in args.items() if v is not None)

name = args.pop("name")
os.system("rm -r -f " + name + " && mkdir " + name)
os.chdir(name)

run_all = args.pop("all")
run_relate = args.pop("relate")
run_tsinfer = args.pop("tsinfer")
run_mtmrca = args.pop("mtmrca")

if run_all:
  run_relate = True
  run_tsinfer = True
  run_mtmrca = True

### default arguments ###
N_per_pop = args.get("N_per_pop", 100)
n = args.get("n", 3)
migration_rate = args.get("migration_rate", 0.05)
time_move = args.get("time_move", 100)

l = args.get("l", 32000000)
mutation_rate = args.get("mutation_rate", 1e-8)
recomb_rate = args.get("recomb_rate", 1e-8)
cas_ratio = args.get("cas_ratio", 0.1)
obs_ratio = args.get("obs_ratio", 0.2)
h2g = args.get("h2g", 1.0)
Alpha = args.get("Alpha", -1)
Beta = args.get("Beta", 1)

N_B = 2100
N_EU0 = 1000
N_AF = 12300
N_A = 7300
r_EU = 0.004
generation_time = 25
T_EU_AS = 21.2e3 / generation_time
T_B = 140e3 / generation_time
T_AF = 220e3 / generation_time
N_EU = N_EU0 / math.exp(-r_EU * T_EU_AS)

### simulate ###
print(args)
print(str(datetime.datetime.now()))

# tree sequence
N = N_per_pop * n * n

migration_matrix = step_mig_mat(migration_rate, n)
migration_matrix = np.append(migration_matrix, np.zeros( (1, n*n) ), axis = 0)
migration_matrix = np.append(migration_matrix, np.zeros(( (n*n+1) ,1)), axis = 1)

population_configurations = [msprime.PopulationConfiguration(sample_size=N_per_pop, initial_size = 1000)] * n * n
population_configurations.append(msprime.PopulationConfiguration(sample_size = 0, initial_size = 1000 * n * n))

demo_events=[msprime.MassMigration(time=time_move, source=i, destination= n*n, proportion=1.0) 
                          for i in range(n * n)]
demo_events.append(msprime.MigrationRateChange(time=time_move,rate=0))

trees = msprime.simulate(population_configurations = population_configurations, migration_matrix=migration_matrix,
                         length = l, recombination_rate = recomb_rate, mutation_rate = mutation_rate, 
                         demographic_events = demo_events)

variants = trees.variants()
MAFs = np.array([v.genotypes.mean() for v in trees.variants()])
loci = np.array([v.position for v in trees.variants()])
M = loci.shape[0]

# observation
idx_5 = MAFs >= 0.005
M_5 = idx_5.sum()
MAFs_5 = MAFs[idx_5]

loci_ceil = np.ceil(loci)
overlapped = np.insert(loci_ceil[:-1] == loci_ceil[1:], 1, False)
non_overlapped = np.logical_not(overlapped)

observable =  np.logical_and(idx_5, non_overlapped)
M_observable = observable.sum()

weights = np.multiply(np.power(MAFs, Beta), np.power(1-MAFs, Beta))
weights = np.multiply(weights, observable)
weights /= weights.sum()

M_obs = int(round(M_observable * obs_ratio))
obss = np.random.choice(np.where(observable)[0], M_obs, replace = False, p = weights[observable]); obss.sort()

# phenotype
M_cas = int(round(M * cas_ratio))
weights = np.multiply(np.power(MAFs, Alpha), np.power(1-MAFs, Alpha))
weights /= weights.sum()
cass = np.random.choice(range(M), M_cas, replace = False, p = weights); cass.sort()
X_cas = getX(trees, cass).astype("float")

betas = np.random.normal(scale = np.sqrt(h2g / M_cas), size = (M_cas, 1))

G = np.dot(X_cas, betas); G.shape = (N, )
s2g = np.var(G, ddof = 1)
s2e = s2g * (1/h2g - 1)

e = np.random.normal(scale=np.sqrt(s2e), size=N)
y = G + e

### compute Ks ###
K_obs = getK(trees, obss)
K_cas = getK(trees, cass)
K_all = getK(trees, np.arange(M))
EK, _, EK_mu = varGRM_C(trees, var = False)

if run_mtmrca:
  mtmrca_c, _ = mTMRCA_C(trees)
  mtmrca, _ = mTMRCA(trees)
  gmtmrca, _ = gmTMRCA(trees)
  hmtmrca, _ = hmTMRCA(trees)

### running relate ###
if run_relate:
  os.mkdir("relate")
  os.chdir("relate")
  
  X_obs = getX(trees, obss)
  loci_obs = np.ceil(loci[obss]).astype(int)
  
  haps_file = open(name + ".haps", 'a')
  i = 0
  for idx, obs in enumerate(obss):
    string = "1 snp" + str(obs+1) + " " + str(loci_obs[idx]) + " A" + " T "
    string = string + " ".join(map(str, X_obs[:, idx])) + "\n"
    bytes = haps_file.write(string)
    i += 1
  haps_file.close()
  os.system("gzip -f " + name + ".haps > " + name + ".haps.gz && rm -f " + name + ".haps")
  
  sample_file = open(name + ".sample",'a')
  sample_file.write("ID_1 ID_2 missing\n0 0 0\n")
  for idx in range(int(N)):
    string = "UNR" + str(idx+1) + " NA" + " 0\n"
    bytes = sample_file.write(string)
  sample_file.close()
  
  map_file = open(name + ".relate.map",'a')
  map_file.write("pos COMBINED_rate Genetic_Map\n")
  for idx, obs in enumerate(obss):
    string = str(loci_obs[idx]) + " " + str(1) + " "
    string = string + str(loci_obs[idx]/1000000) + "\n"
    bytes = map_file.write(string)
  map_file.close()
  
  os.system("~/bin/relate.sh " + name + ".haps.gz " + name + ".sample " + name + ".relate.map " + name)
  
  trees_relate = tskit.load(name + ".trees")
  EK_relate, _, EK_relate_mu = varGRM_C(trees_relate)
  
  os.chdir("..")

### running tsinfer
if run_tsinfer:
  os.mkdir("tsinfer")
  os.chdir("tsinfer")
  X_obs = getX(trees, obss)
  loci_obs = np.ceil(loci[obss]).astype(int)
  with tsinfer.SampleData(path = name + ".samples", sequence_length = l) as sample_data:
    for idx, obs in enumerate(obss):
      sample_data.add_site(loci_obs[idx], X_obs[:, idx])
  
  os.system("~/bin/tsinfer infer " + name + ".samples -p -t 4")
  
  trees_tsinfer = tskit.load(name + ".trees")
  EK_tsinfer, _, EK_tsinfer_mu = varGRM_C(trees_tsinfer)
  
  os.chdir("..")

### collect Ks and compute correlation ###
Ks = {"K_all":K_all, "K_obs":K_obs, "K_cas":K_cas, "EK":EK}
if run_relate:
  Ks["EK_relate"] = EK_relate
if run_tsinfer:
  Ks["EK_tsinfer"] = EK_tsinfer
if run_mtmrca:
  Ks["mtmrca_c"] = mtmrca_c
  Ks["mtmrca"] = mtmrca
  Ks["gmtmrca"] = gmtmrca
  Ks["hmtmrca"] = hmtmrca

# haploid
diags = np.diag_indices(int(N))
non_diags = np.where(~np.eye(int(N),dtype=bool))
table = {}
for key in Ks.keys():
  table[key] = Ks[key][non_diags].flatten()
  
table = pd.DataFrame(data=table)
corr = table.corr(method ='pearson')

# diploid
maternals = np.array(range(0, N, 2))
paternals = np.array(range(1, N, 2))
Ks_dip = {}
for key in Ks.keys():
  Ks_dip[key] = 0.5 * (Ks[key][maternals, :][:, maternals] + Ks[key][maternals, :][:, paternals] + \
                       Ks[key][paternals, :][:, maternals] + Ks[key][paternals, :][:, paternals])

diags = np.diag_indices(int(N/2))
non_diags = np.where(~np.eye(int(N/2),dtype=bool))
table_dip = {}
for key in Ks_dip.keys():
  table_dip[key] = Ks_dip[key][non_diags].flatten()
  
table_dip = pd.DataFrame(data=table_dip)
corr_dip = table_dip.corr(method ='pearson')

### output ###
args = {"l":l, "N":N, "mutation_rate":mutation_rate, "recomb_rate":recomb_rate,
        "cas_ratio":cas_ratio, "obs_ratio":obs_ratio, "h2g":h2g, "Alpha":Alpha, "Beta":Beta}

results = {"args":args, "Ks":Ks, "corr":corr, "corr_dip":corr_dip, "obss":obss}

with open("results.p", 'wb') as f:
  pickle.dump(results, f)

trees.dump("simulation.trees")

