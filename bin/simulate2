#!/usr/bin/env python

### importing packages
import argparse
import os
import numpy as np
import pandas as pd
import pickle
import datetime
import tsinfer
import tsdate
import math
import msprime
import tskit
from egrm import varGRM_C, mTMRCA_C, mTMRCA, gmTMRCA, hmTMRCA

### ad-hoc functions ###
def remove_monomorphic(trees):
  tables = trees.tables
  tables.sites.clear()
  tables.mutations.clear()
  n = trees.num_samples
  for tree in trees.trees():
     for site in tree.sites():
        visited = False
        for mutation in site.mutations:
           k = tree.num_samples(mutation.node)
           if k > 0 and k < n:
               if not visited:
                   visited = True
                   site_id = tables.sites.add_row(site.position, site.ancestral_state, metadata=site.metadata)
               tables.mutations.add_row(site_id, mutation.node, mutation.derived_state, parent=-1, metadata=None)
  tables.compute_mutation_parents()
  return tables.tree_sequence()

def getX(trees, idx):
  N = trees.num_samples
  M = idx.shape[0]
  X = np.zeros((N, M)).astype("int")
  i = 0; num = 0
  for v in trees.variants():
    if i in idx:
      X[:, num] = v.genotypes; num += 1
    i += 1
  return X

def getK(trees, idx):
  N = trees.num_samples
  M = idx.shape[0]
  K_all = np.zeros((N, N))
  for idx_ in np.split(idx, range(1000, M, 1000)):
    Z = getX(trees, idx_).astype("float")
    Z -= Z.mean(axis=0); Z /= Z.std(axis=0)
    K_all += np.dot(Z, np.transpose(Z))
    del Z
  K_all /= M
  return K_all


### parse arguments ###
parser=argparse.ArgumentParser()

# name of simulation
parser.add_argument('--name', default = 'tmp', type = str, help='output file name')

# workflow control
parser.add_argument('--run_all', '--all', action='store_true', help='run all steps')
parser.add_argument('--run_relate', '--relate', action='store_true', help='run relate tree reconstruction')
parser.add_argument('--run_tsinfer', '--tsinfer', action='store_true', help='run tsinfer tree reconstruction')
parser.add_argument('--run_mtmrca', '--mtmrca', action='store_true', help='compute mean TMRCA')
parser.add_argument('--run_impute', '--impute', action='store_true', help='compute K_imputed')

# population structure arguments
parser.add_argument('--demo', type = str, default = 'ooa', help='demography model')
parser.add_argument('--nrow', type = int, default = '1', help='number of rows of populations')
parser.add_argument('--ncol', type = int, default = '1', help='number of columns of populations')
parser.add_argument('--migration_rate', type = float, default = 0.01, help='migration rate')
parser.add_argument('--time_move', type = float, default = 100, help='move time')

# sample sizes arguments
parser.add_argument('--N', type = int, help='total sample size')
parser.add_argument('--n', type = int, help='sample size in each population')
parser.add_argument('--ns', type = int, nargs='*', help='list of sample sizes in each population')

parser.add_argument('--ns_ref', type = int, nargs='*', help='list of sample sizes in each population')

# genetics arguments
parser.add_argument('--l', type = int, default = 3e7, help='chromosome length')
parser.add_argument('--mutation_rate', default = 1e-8, type = float, help='mutation rate')
parser.add_argument('--recomb_rate', default = 1e-8, type = float, help='recombination rate')
parser.add_argument('--cas_ratio', default = 0.1, type = float, help='M_cas / M')
parser.add_argument('--obs_ratio', default = 0.2, type = float, help='M_obs / M_5')
parser.add_argument('--h2g', default = 1.0, type = float, help='heritability')
parser.add_argument('--Alpha', default = -1, type = float, help='causal probability parameter')
parser.add_argument('--Beta', default = 1, type = float, help='observation probability parameter')

args = vars(parser.parse_args())
locals().update(args)

name = args.pop("name")
os.system("rm -r -f " + name + " && mkdir " + name)
os.chdir(name)

if run_all:
  run_relate = True
  run_tsinfer = True
  run_mtmrca = True
  run_impute = True


### processing samples sizes ###
if (N is not None) + (n is not None) + (ns is not None) != 1:
  print("one among N, n and ns should be specified")
  sys.exit()

if (N is not None):
  if N % (nrow * ncol) != 0:
    print("only one among N, n and ns should be specified")
    sys.exit()
  ns = [int(N / nrow / ncol)] * nrow * ncol

if (n is not None):
  N = n * nrow * ncol
  ns = [n] * nrow * ncol

if (ns is not None):
  if len(ns) != nrow * ncol:
    print("length of ns should equal nrow * ncol")
    sys.exit()
  N = sum(ns)

if (N_ref is not None) + (ns_ref is not None) != 1:
  print("one among N, n and ns should be specified")
  sys.exit()

if (ns_ref is None):
  ns_ref = [0] * nrow * ncol


### simulate tree sequence ###
N_B = 2100
N_EU0 = 1000
N_AF = 12300
N_A = 7300
r_EU = 0.004
generation_time = 25
T_EU_AS = 21.2e3 / generation_time
T_B = 140e3 / generation_time
T_AF = 220e3 / generation_time
N_EU = N_EU0 / math.exp(-r_EU * T_EU_AS)

