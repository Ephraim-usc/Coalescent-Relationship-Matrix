#!/usr/bin/env python

### importing packages
import argparse
import os
import numpy as np
import pandas as pd
import pickle
import datetime
import tsinfer
import tsdate
import math
import msprime
import tskit
from egrm import varGRM_C, mTMRCA_C

### ad-hoc functions ###
def getX(trees, idx):
  N = trees.num_samples
  M = idx.shape[0]
  X = np.zeros((N, M)).astype("int")
  i = 0; num = 0
  for v in trees.variants():
    if i in idx:
      X[:, num] = v.genotypes; num += 1
    i += 1
  return X

def getK(trees, idx):
  N = trees.num_samples
  M = idx.shape[0]
  K_all = np.zeros((N, N))
  for idx_ in np.split(idx, range(1000, M, 1000)):
    Z = getX(trees, idx_).astype("float")
    Z -= Z.mean(axis=0); Z /= Z.std(axis=0)
    K_all += np.dot(Z, np.transpose(Z))
    del Z
  K_all /= M

### parse arguments ###
parser=argparse.ArgumentParser()

# name of simulation
parser.add_argument('--name', type = str, help='output file name')

# workflow control
parser.add_argument('--all', help='run all steps', action='store_true')
parser.add_argument('--relate', help='run relate tree reconstruction', action='store_true')
parser.add_argument('--tsinfer', help='run tsinfer tree reconstruction', action='store_true')
parser.add_argument('--mtmrca', help='compute mean TMRCA', action='store_true')

# simulation arguments
parser.add_argument('--l', type = int, help='chromosome length')
parser.add_argument('--N', type = int, help='population size')
parser.add_argument('--mutation_rate', type = float, help='mutation rate')
parser.add_argument('--recomb_rate', type = float, help='recombination rate')
parser.add_argument('--cas_ratio', type = float, help='M_cas / M')
parser.add_argument('--obs_ratio', type = float, help='M_obs / M_5')
parser.add_argument('--h2g', type = float, help='heritability')
parser.add_argument('--Alpha', type = float, help='Alpha -- causal probability parameter')
parser.add_argument('--Beta', type = float, help='Beta -- observation probability parameter')

args = vars(parser.parse_args())
args = dict((k,v) for k,v in args.items() if v is not None)

name = args.pop("name")
os.system("rm -r -f " + name + " && mkdir " + name " && cd " + name)

run_all = args.pop("all")
run_relate = args.pop("relate")
run_tsinfer = args.pop("tsinfer")
run_mtmrca = args.pop("mtmrca")

if run_all:
  run_relate = True
  run_tsinfer = True
  run_mtmrca = True

### default arguments ###
l = args.get("l", 32000000)
N = args.get("N", 1000)
mutation_rate = args.get("mutation_rate", 1e-8)
recomb_rate = args.get("recomb_rate", 1e-8)
cas_ratio = args.get("cas_ratio", 0.1)
obs_ratio = args.get("obs_ratio", 0.2)
h2g = args.get("h2g", 1.0)
Alpha = args.get("Alpha", -1)
Beta = args.get("Beta", 1)

N_B = 2100
N_EU0 = 1000
N_AF = 12300
N_A = 7300
r_EU = 0.004
generation_time = 25
T_EU_AS = 21.2e3 / generation_time
T_B = 140e3 / generation_time
T_AF = 220e3 / generation_time
N_EU = N_EU0 / math.exp(-r_EU * T_EU_AS)

### simulate ###
print(args)
print(str(datetime.datetime.now()))

# tree sequence
population_configurations = [msprime.PopulationConfiguration(sample_size = N, initial_size = N_EU, growth_rate = r_EU)]

demo_events = [msprime.PopulationParametersChange(time=T_EU_AS, initial_size = N_B, growth_rate=0),
               msprime.PopulationParametersChange(time=T_B, initial_size = N_AF, growth_rate=0),
               msprime.PopulationParametersChange(time=T_AF, initial_size = N_A, growth_rate=0)]

trees = msprime.simulate(length = l, population_configurations = population_configurations, 
                         recombination_rate = recomb_rate, mutation_rate = mutation_rate, 
                         demographic_events = demo_events)

variants = trees.variants()
MAFs = np.array([v.genotypes.mean() for v in trees.variants()])
loci = np.array([v.position for v in trees.variants()])
M = loci.shape[0]

# observation
idx_5 = MAFs >= 0.005
M_5 = idx_5.sum()
MAFs_5 = MAFs[idx_5]

loci_ceil = np.ceil(loci)
overlapped = np.insert(loci_ceil[:-1] == loci_ceil[1:], 1, False)
non_overlapped = np.logical_not(overlapped)

observable =  np.logical_and(idx_5, non_overlapped)
M_observable = observable.sum()

weights = np.multiply(np.power(MAFs, Beta), np.power(1-MAFs, Beta))
weights = np.multiply(weights, observable)
weights /= weights.sum()

M_obs = int(round(M_observable * obs_ratio))
obss = np.random.choice(np.where(observable)[0], M_obs, replace = False, p = weights[observable]); obss.sort()

# phenotype
M_cas = int(round(M * cas_ratio))
weights = np.multiply(np.power(MAFs, Alpha), np.power(1-MAFs, Alpha))
weights /= weights.sum()
cass = np.random.choice(range(M), M_cas, replace = False, p = weights); cass.sort()
X_cas = getX(trees, cass).astype("float")

betas = np.random.normal(scale = np.sqrt(h2g / M_cas), size = (M_cas, 1))

G = np.dot(X_cas, betas); G.shape = (N, )
s2g = np.var(G, ddof = 1)
s2e = s2g * (1/h2g - 1)

e = np.random.normal(scale=np.sqrt(s2e), size=N)
y = G + e

### compute Ks ###
K_obs = getK(trees, obss)
K_cas = getK(trees, cass)
K_all = getK(trees, np.arange(M))
EK, _, EK_mu = varGRM_C(trees, var = False)
mtmrca, _ = mTMRCA_C(trees)

### running relate ###
if run_relate:
  os.mkdir("relate")
  os.chdir("relate")
  
  X_obs = getX(trees, obss)
  loci_obs = np.ceil(loci[obss]).astype(int)
  
  haps_file = open(name + ".haps", 'a')
  i = 0
  for idx, obs in enumerate(obss):
    string = "1 snp" + str(obs+1) + " " + str(loci_obs[idx]) + " A" + " T "
    string = string + " ".join(map(str, X_obs[:, idx])) + "\n"
    bytes = haps_file.write(string)
    i += 1
  haps_file.close()
  os.system("gzip -f " + name + ".haps > " + name + ".haps.gz && rm -f " + name + ".haps")
  
  sample_file = open(name + ".sample",'a')
  sample_file.write("ID_1 ID_2 missing\n0 0 0\n")
  for idx in range(int(N)):
    string = "UNR" + str(idx+1) + " NA" + " 0\n"
    bytes = sample_file.write(string)
  sample_file.close()
  
  map_file = open(name + ".relate.map",'a')
  map_file.write("pos COMBINED_rate Genetic_Map\n")
  for idx, obs in enumerate(obss):
    string = str(loci_obs[idx]) + " " + str(1) + " "
    string = string + str(loci_obs[idx]/1000000) + "\n"
    bytes = map_file.write(string)
  map_file.close()
  
  os.system("~/bin/relate.sh " + name + ".haps.gz " + name + ".sample " + name + ".relate.map " + name)
  
  trees_relate = tskit.load(name + ".trees")
  EK_relate, _, EK_relate_mu = varGRM_C(trees_relate)
  
  os.chdir("..")

### running tsinfer
if run_tsinfer:
  os.mkdir("tsinfer")
  os.chdir("tsinfer")
  X_obs = getX(trees, obss)
  loci_obs = np.ceil(loci[obss]).astype(int)
  with tsinfer.SampleData(path = name + ".samples", sequence_length = l) as sample_data:
    for idx, obs in enumerate(obss):
      sample_data.add_site(loci_obs[idx], X_obs[:, idx])
  
  os.system("~/bin/tsinfer infer " + name + ".samples -p -t 4")
  
  trees_tsinfer = tskit.load(name + ".trees")
  EK_tsinfer, _, EK_tsinfer_mu = varGRM_C(trees_tsinfer)
  
  os.chdir("..")

### output ###
args = {"l":l, "N":N, "mutation_rate":mutation_rate, "recomb_rate":recomb_rate,
        "cas_ratio":cas_ratio, "obs_ratio":obs_ratio, "h2g":h2g, "Alpha":Alpha, "Beta":Beta}

Ks = {"K_all":K_all, "K_obs":K_obs, "K_cas":K_cas}
if run_relate:
  Ks["EK_relate"] = EK_relate
if run_tsinfer:
  Ks["EK_tsinfer"] = EK_tsinfer
if run_mtmrca:
  Ks["mtmrca"] = mtmrca

result = {"args":args, "Ks":Ks}

with open("results.p", 'wb') as f:
  pickle.dump(results, f)



